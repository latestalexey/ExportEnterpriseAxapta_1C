Перем ТипыДокументов;

&НаСервере
Процедура ПриСозданииНаСервере(Отказ, СтандартнаяОбработка)
	Параметры.Свойство("ДополнительнаяОбработкаСсылка", ДополнительнаяОбработкаСсылка);
	Для Каждого ЭлементСписка Из ТипыДокументов Цикл
		СтрокаТЧ = Объект.ТаблицаТиповДокументов.Добавить();
		СтрокаТЧ.ТипДокумента = ЭлементСписка.Ключ;
		СтрокаТЧ.Признак = ЭлементСписка.Значение;
	КонецЦикла;
	
	ОбъектДляСервера = РеквизитФормыВЗначение("Объект");
	
	Макет = ОбъектДляСервера.ПолучитьМакет("Классификатор");
	Чтение = Новый ЧтениеXML;
	Чтение.УстановитьСтроку(Макет.ПолучитьТекст());
	
	ОбъектДляСервера.Классификатор.Загрузить(СериализаторXDTO.ПрочитатьXML(Чтение));
	
	КлассификаторXML = ОбъектДляСервера.ПолучитьМакет("ОбщероссийскийКлассификаторВалют").ПолучитьТекст();
	
	КлассификаторТаблица = ПрочитатьXMLВТаблицу(КлассификаторXML).Данные;
	
	Для Каждого ЗаписьОКВ Из КлассификаторТаблица Цикл
		НоваяСтрока = ОбъектДляСервера.Валюты.Добавить();
		НоваяСтрока.КодВалютыЦифровой         = ЗаписьОКВ.Code;
		НоваяСтрока.КодВалютыБуквенный        = ЗаписьОКВ.CodeSymbol;
		НоваяСтрока.Наименование              = ЗаписьОКВ.Name;
		НоваяСтрока.СтраныИТерритории         = ЗаписьОКВ.Description;
		НоваяСтрока.Загружается               = ЗаписьОКВ.RBCLoading;
		НоваяСтрока.ПараметрыПрописиНаРусском = ЗаписьОКВ.NumerationItemOptions;
	КонецЦикла;
	
	ЗначениеВРеквизитФормы(ОбъектДляСервера, "Объект");
	
	ПараметрыСоединения = СтроковыеФункцииКлиентСервер.ПолучитьПараметрыИзСтроки(СтрокаСоединенияИнформационнойБазы());
	Если ПараметрыСоединения.Свойство("Ref") И ПараметрыСоединения.Свойство("Srvr") Тогда
		Если ПараметрыСоединения.Ref = "MercuryClassicSH" Тогда
			Объект.КодТовараВMerExternalItemId = Истина;
		КонецЕсли;
	ИначеЕсли ПараметрыСоединения.Свойство("File") Тогда
		Если Найти(ПараметрыСоединения.File, "Buh_Mercury_3.0") > 0 Тогда
			Объект.КодТовараВMerExternalItemId = Истина;
		КонецЕсли;
	КонецЕсли;
	Объект.ТипВыгрузкиТовара = 1;
КонецПроцедуры

&НаКлиенте
Функция ВыполнитьЗапросADO(Connection, CommandText)
	Cmd=Новый COMОбъект("ADODB.Command");
	Cmd.ActiveConnection = Connection;
	Cmd.CommandText = CommandText;
	Cmd.CommandTimeout = 0;		//120;
	Cmd.CommandType = 1; //ТипКомандыАДО("adCmdText");

	RecordSet = Новый COMОбъект("ADODB.RecordSet");
	RecordSet = Cmd.Execute();
	Возврат RecordSet;
	
КонецФункции

&НаСервере
Функция ЗаполнитьСписокДокументовНаСервере()
	
	ОбъектДляСервера = РеквизитФормыВЗначение("Объект");
	
	ВыгрузкаЗавершена = ОбъектДляСервера.ЗаполнитьСписокДокументов();//ОбъектДляСервера.НачалоПериода, ОбъектДляСервера.КонецПериода);
	
	ЗначениеВРеквизитФормы(ОбъектДляСервера, "Объект");
	
	Возврат ВыгрузкаЗавершена;
КонецФункции

&НаКлиенте
Процедура ЗаполнитьСписокДокументов(Команда)
	ЗаполнитьСписокДокументовНаСервере();
КонецПроцедуры

&НаКлиенте
Процедура ФайлВыгрузкиНачалоВыбора(Элемент, ДанныеВыбора, СтандартнаяОбработка)
	
	ДиалогВыбораФайла = Новый ДиалогВыбораФайла(РежимДиалогаВыбораФайла.Сохранение);
	
	ДиалогВыбораФайла.Фильтр = "Файл данных (*.xml)|*.xml";
	ДиалогВыбораФайла.Заголовок = "Выберите файл";
	ДиалогВыбораФайла.ПредварительныйПросмотр = Ложь;
	ДиалогВыбораФайла.Расширение = "xml";
	ДиалогВыбораФайла.ИндексФильтра = 0;
	ДиалогВыбораФайла.ПолноеИмяФайла = Элемент.ТекстРедактирования;
	ДиалогВыбораФайла.ПроверятьСуществованиеФайла = Ложь;
	
	Если ДиалогВыбораФайла.Выбрать() Тогда
		
		Объект.ФайлВыгрузки = ДиалогВыбораФайла.ПолноеИмяФайла;
		
	КонецЕсли;

КонецПроцедуры

&НаСервере
Функция ВыполнитьВыгрузкуНаСервере(АдресФайла)
	Если Не ПроверитьЗаполнение() ТОгда
		Возврат Ложь;
	КонецЕсли;
	
	ВременныйФайл = ПолучитьИмяВременногоФайла(".xml");
	Файл = Новый Файл(ВременныйФайл);
	ИмяФайлаВыгрузки = ВременныйФайл;
		
	ОбъектДляСервера = РеквизитФормыВЗначение("Объект");
	ВыгрузкаЗавершена = ОбъектДляСервера.ВыполнитьВыгрузку(ИмяФайлаВыгрузки);
	ЗначениеВРеквизитФормы(ОбъектДляСервера, "Объект");
	
	АдресФайла = ПоместитьВоВременноеХранилище(Новый ДвоичныеДанные(ИмяФайлаВыгрузки), ЭтаФорма.УникальныйИдентификатор);
	УдалитьФайлы(ИмяФайлаВыгрузки);
	
	Если Не ВыгрузкаЗавершена Тогда
		
		Сообщить("Ошибка создания файла.");
		
	КонецЕсли;
	
	Возврат ВыгрузкаЗавершена;
КонецФункции

&НаКлиенте
Процедура Выгрузить(Команда)
	Перем АдресФайла;
	
	ОчиститьСообщения();
	
	Состояние(Нстр("ru='Выполняется выгрузка документов. Пожалуйста, подождите...'"));
	Попытка
		Если ВыполнитьВыгрузкуНаСервере(АдресФайла) Тогда
			
			Сообщить("Выгрузка документов успешно завершена.");
			
			ПолучитьФайл(АдресФайла, Объект.ФайлВыгрузки, Ложь);
		КонецЕсли;
	Исключение
		Сообщить("Произошла ошибка: " + ОписаниеОшибки());
	КонецПопытки;
КонецПроцедуры

&НаСервере
Функция ЗаполнитьОстаткиНаСервере()
	
	ОбъектДляСервера = РеквизитФормыВЗначение("Объект");
	
	ВыгрузкаЗавершена = ОбъектДляСервера.ЗаполнитьОстатки();
	
	ЗначениеВРеквизитФормы(ОбъектДляСервера, "Объект");
	
	Возврат ВыгрузкаЗавершена;
КонецФункции

&НаКлиенте
Процедура КомандаЗаполнитьОстатки(Команда)
	ЗаполнитьОстаткиНаСервере();
КонецПроцедуры

&НаКлиенте
Процедура ВыгрузитьОстатки1(Команда)
	
	ОчиститьСообщения();
	
	// Переключаем режим - страницу.
	ТекстСостоянияЗагрузки = НСтр("ru = 'Загрузка остатков...'");
	
	ОповещениеОПрогрессеВыполнения = Новый ОписаниеОповещения("ПрогрессВыполнения", ЭтотОбъект);
	Задание = ВыгрузитьОстаткиНаСервере1();
	
	Если Задание <> Неопределено Тогда
		НастройкиОжидания = ДлительныеОперацииКлиент.ПараметрыОжидания(ЭтотОбъект);
		НастройкиОжидания.ВыводитьОкноОжидания = Ложь;
		НастройкиОжидания.ПолучатьРезультат = Истина;
		НастройкиОжидания.ВыводитьСообщения = Ложь;
		НастройкиОжидания.Интервал = 1;
		НастройкиОжидания.ОповещениеОПрогрессеВыполнения = ОповещениеОПрогрессеВыполнения;
		//НастройкиОжидания.ОповещениеПользователя.Показать = Истина;
		
		Обработчик = Новый ОписаниеОповещения("ПослеФоновойВыгрузкиОстатков", ЭтотОбъект);
		ДлительныеОперацииКлиент.ОжидатьЗавершение(Задание, Обработчик, НастройкиОжидания);
	КонецЕсли;
КонецПроцедуры

&НаСервере
Функция ВыгрузитьОстаткиНаСервере1()
	// Возможно, что фоновое задание было запущено раньше, 
	// пользователь дал команду его отменить, однако задание не отменено.
	// В таком случае не следует запускать задание повторно - следует дождаться его выполнения.
	// Мы можем отследить ситуацию только, если все это происходит в одной форме.
	// Потому что подсистема ДлительныеОперации не умеет устанавливать ключ фонового задания.
	ОбработкаОбъект = РеквизитФормыВЗначение("Объект");
	
	СтруктураПараметров = Новый Структура;
	СтруктураПараметров.Вставить("НачалоПериода", ОбработкаОбъект.НачалоПериода);
	СтруктураПараметров.Вставить("ИдентификаторФормы", ЭтаФорма.УникальныйИдентификатор);
	СтруктураПараметров.Вставить("ИмяФормы", ЭтаФорма.ИмяФормы);
	//СтруктураПараметров.Вставить("ОбработкаОбъект", ОбработкаОбъект);
	
	Если ПодсистемаСуществует("СтандартныеПодсистемы.БазоваяФункциональность") Тогда
		
		Если ЗначениеЗаполнено(ИдентификаторЗадания) Тогда
			Попытка
				ЗаданиеВыполнено = ДлительныеОперации.ЗаданиеВыполнено(ИдентификаторЗадания);
			Исключение
				ЗаданиеВыполнено = Истина;
			КонецПопытки;
		Иначе
			ЗаданиеВыполнено = Истина;
		КонецЕсли;
		Если ЗаданиеВыполнено = Ложь Тогда
			// Надо ждать
			Возврат Неопределено;
		КонецЕсли;
		
		НаименованиеЗадания = НСтр("ru = 'Выгрузка остатков'");
		
		ВыполняемыйМетод = "ДлительныеОперации.ВыполнитьПроцедуруМодуляОбъектаОбработки";
		
		ЭтоВнешняяОбработка = Не Метаданные.Обработки.Содержит(ОбработкаОбъект.Метаданные());
		
		ПараметрыЗадания = Новый Структура;
		ПараметрыЗадания.Вставить("ИмяОбработки", ОбработкаОбъект.ИспользуемоеИмяФайла);
		ПараметрыЗадания.Вставить("ИмяМетода", "ВыгрузитьОстатки1");
		ПараметрыЗадания.Вставить("ПараметрыВыполнения", СтруктураПараметров);
		ПараметрыЗадания.Вставить("ЭтоВнешняяОбработка", ЭтоВнешняяОбработка);
		ПараметрыЗадания.Вставить("ДополнительнаяОбработкаСсылка", Неопределено);
		
		МодульДлительныеОперации = ОбщийМодуль("ДлительныеОперации");
		
		ПараметрыВыполнения = МодульДлительныеОперации.ПараметрыВыполненияВФоне(ЭтаФорма.УникальныйИдентификатор);
		ПараметрыВыполнения.НаименованиеФоновогоЗадания = НаименованиеЗадания;
		ПараметрыВыполнения.ЗапуститьВФоне = Истина;
		
		РезультатФоновогоЗадания = МодульДлительныеОперации.ВыполнитьВФоне(ВыполняемыйМетод, ПараметрыЗадания, ПараметрыВыполнения);
		ИдентификаторЗадания = РезультатФоновогоЗадания.ИдентификаторЗадания;
		Возврат РезультатФоновогоЗадания;
	Иначе
		АдресРезультата = ПоместитьВоВременноеХранилище(Неопределено, ЭтаФорма.УникальныйИдентификатор);
		ОбработкаОбъект.ВыгрузитьОстатки(СтруктураПараметров, АдресРезультата);
		ЗавершениеЗагрузки(АдресРезультата);
	КонецЕсли;
КонецФункции

&НаКлиенте
Процедура ПрогрессВыполнения(Результат, ДополнительныеПараметры) Экспорт
	
	Если Результат.Статус = "Выполняется" Тогда
		РезультатЗадания = ПрочитатьПрогрессИСообщения(Результат.ИдентификаторЗадания);
		Если РезультатЗадания.Прогресс <> Неопределено Тогда
			Состояние("Обработка данных", РезультатЗадания.Прогресс.Процент, РезультатЗадания.Прогресс.Текст);
		КонецЕсли;
		Если РезультатЗадания.Сообщения <> Неопределено Тогда
			Для Каждого Сообщение Из РезультатЗадания.Сообщения Цикл
				ОбщегоНазначенияКлиентСервер.СообщитьПользователю(Сообщение.Текст, Сообщение.КлючДанных, Сообщение.Поле, Сообщение.ПутьКДанным);
			КонецЦикла;
		КонецЕсли;
	КонецЕсли;
	
КонецПроцедуры

&НаСервереБезКонтекста
Функция ПрочитатьПрогрессИСообщения(ИдентификаторЗадания)
	Возврат ДлительныеОперации.ОперацияВыполнена(ИдентификаторЗадания, Истина, Истина, Истина);
КонецФункции

&НаКлиенте
Процедура ПослеФоновойВыгрузкиОстатков(Задание, ДополнительныеПараметры) Экспорт

	Если Задание.Статус = "Ошибка" Тогда
		ТекстОшибки = ТекстОшибки + Задание.КраткоеПредставлениеОшибки;
		ВывестиСообщениеОбОшибке(ТекстОшибки);
	ИначеЕсли Задание.Статус = "Выполнено" Тогда
		РезультатЗадания = ПрочитатьПрогрессИСообщения(ИдентификаторЗадания);
		Если РезультатЗадания.Сообщения <> Неопределено Тогда
			Для Каждого Сообщение Из РезультатЗадания.Сообщения Цикл
				ОбщегоНазначенияКлиентСервер.СообщитьПользователю(Сообщение.Текст, Сообщение.КлючДанных, Сообщение.Поле, Сообщение.ПутьКДанным);
			КонецЦикла;
		КонецЕсли;
		Состояние("Обработка завершена");
		ЗавершениеЗагрузки(Задание.АдресРезультата);
	КонецЕсли;

КонецПроцедуры

&НаКлиенте
Процедура ВывестиСообщениеОбОшибке(Знач ТекстОшибки)
	ОчиститьСообщения();
	ОбщегоНазначенияКлиентСервер.СообщитьПользователю(ТекстОшибки);
КонецПроцедуры

&НаСервере
Функция ЗавершениеЗагрузки(АдресРезультата)
	Результат = ПолучитьИзВременногоХранилища(АдресРезультата);
	УдалитьИзВременногоХранилища(АдресРезультата);
	ОбработкаОбъект = РеквизитФормыВЗначение("Объект");
	ОбработкаОбъект.ТаблицаОстатков.Загрузить(Результат.ТабОстатков.Получить());
	ЗначениеВРеквизитФормы(ОбработкаОбъект, "Объект");
	
	Возврат Истина;

КонецФункции

// Возвращает Истина, если подсистема существует.
//
// Параметры:
//  ПолноеИмяПодсистемы - Строка. Полное имя объекта метаданных подсистема без слов "Подсистема.".
//                        Например: "СтандартныеПодсистемы.БазоваяФункциональность".
//
// Пример вызова необязательной подсистемы:
//
//  Если ОбщегоНазначения.ПодсистемаСуществует("СтандартныеПодсистемы.УправлениеДоступом") Тогда
//  	МодульУправлениеДоступом = ОбщегоНазначения.ОбщийМодуль("УправлениеДоступом");
//  	МодульУправлениеДоступом.<Имя метода>();
//  КонецЕсли;
//
// Возвращаемое значение:
//  Булево.
//
&НаСервере
Функция ПодсистемаСуществует(ПолноеИмяПодсистемы)
	
	Если Не ВерсияБСПСоответствуетТребованиям() Тогда
		Возврат Ложь;
	КонецЕсли;
	
	ИменаПодсистем = ИменаПодсистем();
	Возврат ИменаПодсистем.Получить(ПолноеИмяПодсистемы) <> Неопределено;
	
КонецФункции

// Возвращает соответствие имен подсистем и значения Истина;
&НаСервереБезКонтекста
Функция ИменаПодсистем()
	
	Возврат Новый ФиксированноеСоответствие(ИменаПодчиненныхПодсистем(Метаданные));
	
КонецФункции

&НаСервереБезКонтекста
Функция ИменаПодчиненныхПодсистем(РодительскаяПодсистема)
	
	Имена = Новый Соответствие;
	
	Для Каждого ТекущаяПодсистема Из РодительскаяПодсистема.Подсистемы Цикл
		
		Имена.Вставить(ТекущаяПодсистема.Имя, Истина);
		ИменаПодчиненных = ИменаПодчиненныхПодсистем(ТекущаяПодсистема);
		
		Для каждого ИмяПодчиненной Из ИменаПодчиненных Цикл
			Имена.Вставить(ТекущаяПодсистема.Имя + "." + ИмяПодчиненной.Ключ, Истина);
		КонецЦикла;
	КонецЦикла;
	
	Возврат Имена;
	
КонецФункции

&НаСервере
Функция ВерсияБСПСоответствуетТребованиям()
	ОбработкаОбъект = РеквизитФормыВЗначение("Объект");
	Возврат ОбработкаОбъект.ВерсияБСПСоответствуетТребованиям();
КонецФункции

// Возвращает ссылку на общий модуль по имени.
//
// Параметры:
//  Имя          - Строка - имя общего модуля, например:
//                 "ОбщегоНазначения",
//                 "ОбщегоНазначенияКлиент".
//
// Возвращаемое значение:
//  ОбщийМодуль.
//
&НаКлиентеНаСервереБезКонтекста
Функция ОбщийМодуль(Имя)
	
#Если Сервер Или ТолстыйКлиентОбычноеПриложение Или ВнешнееСоединение Тогда
	Если Метаданные.ОбщиеМодули.Найти(Имя) <> Неопределено Тогда
		Модуль = Вычислить(Имя);
	Иначе
		Модуль = Неопределено;
	КонецЕсли;
	
	Если ТипЗнч(Модуль) <> Тип("ОбщийМодуль") Тогда
		ВызватьИсключение ПодставитьПараметрыВСтроку(НСтр("ru = 'Общий модуль ""%1"" не найден.'"), Имя);
	КонецЕсли;
#Иначе
	Модуль = Вычислить(Имя);
#Если НЕ ВебКлиент Тогда
	Если ТипЗнч(Модуль) <> Тип("ОбщийМодуль") Тогда
		ВызватьИсключение ПодставитьПараметрыВСтроку(НСтр("ru = 'Общий модуль ""%1"" не найден.'"), Имя);
	КонецЕсли;
#КонецЕсли
#КонецЕсли
	
	Возврат Модуль;
	
КонецФункции

&НаКлиентеНаСервереБезКонтекста
Функция ПодставитьПараметрыВСтроку(Знач СтрокаПодстановки,
	Знач Параметр1, Знач Параметр2 = Неопределено, Знач Параметр3 = Неопределено)
	
	СтрокаПодстановки = СтрЗаменить(СтрокаПодстановки, "%1", Параметр1);
	СтрокаПодстановки = СтрЗаменить(СтрокаПодстановки, "%2", Параметр2);
	СтрокаПодстановки = СтрЗаменить(СтрокаПодстановки, "%3", Параметр3);
	
	Возврат СтрокаПодстановки;
КонецФункции

&НаСервере
Функция ВыгрузитьОстаткиНаСервере()
		
	ОбъектДляСервера = РеквизитФормыВЗначение("Объект");
	ВыгрузкаЗавершена = ОбъектДляСервера.ВыгрузитьОстатки();
	ЗначениеВРеквизитФормы(ОбъектДляСервера, "Объект");
	
	Возврат ВыгрузкаЗавершена;
КонецФункции

&НаКлиенте
Процедура ВыгрузитьОстатки(Команда)
	Состояние(Нстр("ru='Выполняется выгрузка остатков. Пожалуйста, подождите...'"));
	ВыгрузитьОстаткиНаСервере();
КонецПроцедуры

&НаКлиенте
Процедура ФайлXLSНачалоВыбора(Элемент, ДанныеВыбора, СтандартнаяОбработка)
	ДиалогВыбораФайла = Новый ДиалогВыбораФайла(РежимДиалогаВыбораФайла.Открытие);
	
	ДиалогВыбораФайла.Фильтр = "Файл данных (*.xls)|*.xls";
	ДиалогВыбораФайла.Заголовок = "Выберите файл";
	ДиалогВыбораФайла.ПредварительныйПросмотр = Ложь;
	ДиалогВыбораФайла.Расширение = "xls";
	ДиалогВыбораФайла.ИндексФильтра = 0;
	ДиалогВыбораФайла.ПолноеИмяФайла = Элемент.ТекстРедактирования;
	ДиалогВыбораФайла.ПроверятьСуществованиеФайла = Истина;
	
	Если ДиалогВыбораФайла.Выбрать() Тогда
		
		Объект.ФайлXLS = ДиалогВыбораФайла.ПолноеИмяФайла;
		
	КонецЕсли;
КонецПроцедуры

&НаСервере
Функция ЗагрузитьXLSНаСервере(МассивXLS)
	ОбъектДляСервера = РеквизитФормыВЗначение("Объект");
	ТаблицаXLS = ПреобразоватьМассивВТаблицуЗначений(МассивXLS);
	Если Объект.ТипДокументаПоУмолчанию = "Заморозки" Тогда
		ВыгрузкаЗавершена = ОбъектДляСервера.ЗагрузитьТаблицуЗаморозок(ТаблицаXLS);
	Иначе
		ВыгрузкаЗавершена = ОбъектДляСервера.ЗагрузитьТаблицуВнешнихПродаж(ТаблицаXLS);
	КонецЕсли;
	ЗначениеВРеквизитФормы(ОбъектДляСервера, "Объект");
КонецФункции

&НаКлиенте
Процедура ЗагрузитьXLS(Команда)
	Перем КолСтрок;
	МассивXLS = ЗагрузитьМетодом_MSADODB(Объект.ФайлXLS, "TDSheet", 1, 0, , КолСтрок);
	ЗагрузитьXLSНаСервере(МассивXLS);
КонецПроцедуры

&НаКлиенте
Функция ЗагрузитьМетодом_MSADODB(Знач ФайлEXCEL, Знач ИмяЛиста, Знач СтрокаЗаголовка = 1, НачСтрока = 0, КонСтрока = 0, КолвоСтрокExcel, 
 Знач ПодключениеADODB = "MicrosoftACEOLEDB12") Экспорт
    Перем СonnectionString, ADODBConnection, ADODBRecordset, ТекстЗапроса;
    Перем КолвоКолонокExcel, Поле, Колонка, ИмяКолонки;
    Перем НоваяСтрока, НомерСтроки;
    Перем ТаблицаРезультат;
	adSchemaTables = 20;
	adSchemaColumns = 4;	 
    
    // Нумерация MS ADODB начинается с 1.
    
    // Переменная "СтрокаЗаголовка", не используется, т.к. HDR=YES, а не HDR=NO.
    // HDR=YES:
    // 1. Считывание заголовков колонок с 1-ой строки.
    // 2. Считываемые данные со 2-ой и последующих строк типизированы. Для варианта HDR=NO: считываемые данные - строка.
    
    // Строка соединения - определение драйвера, который будет использован для подключения к файлу EXCEL.
    Если ПодключениеADODB = "MicrosoftACEOLEDB12" Тогда
        
        // ACE.OLEDB.12.0 - Для использования данного подключения необходимо дополнительное ПО:
        // Microsoft Access Database Engine 2010 Redistributable 32/64 bit.
        СonnectionString = "Provider=Microsoft.ACE.OLEDB.12.0;Data Source= " + СокрЛП(ФайлEXCEL) + ";Extended Properties=""Excel 12.0;HDR=YES;IMEX=1;""";
        
        // Еще один вариант.
        //СтрокаСоединения = "Driver={Microsoft Excel Driver (*.xls, *.xlsx, *.xlsm, *.xlsb)};Dbq=" + СокрЛП(ФайлEXCEL) + ";";
        
    Иначе
        
        // Jet.OLEDB.4.0 - Стандартное подключение, как правило, не требующее установки дополнительного ПО. 
        // Рекомендуется установить последний Service Pack Windows.
        СonnectionString = "Provider=Microsoft.Jet.OLEDB.4.0;Data Source= "  + СокрЛП(ФайлEXCEL) + ";Extended Properties=""Excel 8.0;HDR=YES;IMEX=1;""";
        
        // Еще один вариант.
        //СтрокаСоединения = "Driver={Microsoft Excel Driver (*.xls)};Dbq=" + СокрЛП(ФайлEXCEL) + ";";
        
    КонецЕсли;
    
	//Попытка
        // Инициализация основного объекта ADODB.Connection. Открытие соединения.
        ADODBConnection = Новый COMОбъект("ADODB.Connection");
        ADODBConnection.ConnectionString =  СonnectionString;
        ADODBConnection.Open();
        // Импирически определенный параметр для правильного определения количества строк листа.
        ADODBConnection.CursorLocation = 3;    // По-умолчанию 2.
	//Исключение
	//    Сообщить(НСтр("ru = '"+ОписаниеОшибки()+"'"), СтатусСообщения.Внимание);
	//    Возврат Новый Массив;    // В случае ошибки возвращаем пустую таблицу значений.
	//КонецПопытки;
    
	Recordset = ADODBConnection.OpenSchema(adSchemaColumns);
	Если (Recordset.EOF = Ложь) Тогда
		ИмяЛиста = Recordset.Fields("table_name").Value;
	КонецЕсли;
	Recordset.Close();
    ТекстЗапроса = "SELECT * FROM [" + ИмяЛиста + "]";
    // Создание Recordset. Дочерний объект ADODBConnection. Набор записей по запросу.
	//Попытка
        ADODBRecordset = Новый COMОбъект("ADODB.Recordset");
        ADODBRecordset.Open(ТекстЗапроса, ADODBConnection);
        
        // Проверка заполненности листа.
        Если (ADODBRecordset.EOF ИЛИ ADODBRecordset.BOF) Тогда
            КолвоСтрокExcel = 0;
            Сообщить(НСтр("ru = '" + ИмяЛиста + ": не содержит данных.'"), СтатусСообщения.Внимание);
            
            // Завершение работы.
            // Закрытие Объектов.
            ADODBRecordset.Close();
            ADODBConnection.Close();
            ADODBRecordset   = Неопределено;
            ADODBConnection = Неопределено;
            
            Возврат Новый Массив;    // В случае ошибки возвращаем пустую таблицу значений.
        КонецЕсли;
        
        // Импирически определенные параметры для правильного определения количества строк листа.
        ADODBRecordset.AbsolutePage     = 1;
        ADODBRecordset.AbsolutePosition = 1;
	//Исключение
	//    Сообщить(НСтр("ru = '"+ОписаниеОшибки()+"'"), СтатусСообщения.Внимание);
	//    Возврат Новый Массив;    // В случае ошибки возвращаем пустую таблицу значений.
	//КонецПопытки;
    
    // Параметр, возвращаемый в вызывающую процедуру.
    КолвоСтрокExcel = ADODBRecordset.RecordCount + 1;    // (+1) - учет Строки-Заголовока, которая "съедается".
    КолвоКолонокExcel = ADODBRecordset.Fields.Count;
    
    // Проверка заполненности листа.
     Если КолвоСтрокExcel <= 2 Тогда
        КолвоСтрокExcel = 0;
        Сообщить(НСтр("ru = '" + ИмяЛиста + ": не содержит данных.'"), СтатусСообщения.Внимание);
        
        // Завершение работы.
        // Закрытие Объектов.
        ADODBRecordset.Close();
        ADODBConnection.Close();
        ADODBRecordset   = Неопределено;
        ADODBConnection = Неопределено;
        
        Возврат Новый Массив;    // В случае ошибки возвращаем пустую таблицу значений.
    КонецЕсли;
    
    // Создание результирующей таблицы, в которую будут записываться считанные из EXCEL данные.
    ТаблицаРезультат = Новый Массив;
    
    // Формирование колонок результирующей таблицы.
    
    // "НомерСтроки" - для наглядности и удобства.
    // В зависимости от разрабатываемой обработки.
    // "Сопоставлено" - может быть другим.
    // Здесь же могут быть добавлены другие колонки, не формируемые из содержимого файла EXCEL.
	СтруктураСтроки = Новый Структура ("НомерСтроки, Сопоставлено");
	//ТаблицаРезультат.Колонки.Добавить("НомерСтроки", Новый ОписаниеТипов("Число"), "№", 4);
	//ТаблицаРезультат.Колонки.Добавить("Сопоставлено", Новый ОписаниеТипов("Булево"), "Сопоставлено", 1);
    Для ит = 1 ПО КолвоКолонокExcel Цикл
        
        Поле = ADODBRecordset.Fields.Item(ит - 1);
        ИмяКолонки = "К_" + ит;
		СтруктураСтроки.Вставить(ИмяКолонки);
        //Колонка = ТаблицаРезультат.Колонки.Добавить(ИмяКолонки, , СокрЛП(СтрЗаменить(Поле.Name, "#", ".")));
        // Замена "#" на ".", т.к. при считывании ADODB "." в имени колонки заменяется на "#".
        
	КонецЦикла;
	СтруктураСтроки = Новый ФиксированнаяСтруктура(СтруктураСтроки);
    
    // ТаблицаРезультат: 1-я строка - Строка-Заголовок.
    
    // Добавление этой строки обусловлено исключительно из соображений идентичности содержимого файла EXCEL и ТаблицыЗначений,
    // выводимой на форме Обработки, и дальнейшей обработки строки заголовка
    // с целью сопоставления колонок EXCEL и реквизитов 1С: для Справочников, ПВХ, Регистров, Документов.
    
    // Если в Вашей обработке в результирующей таблице в качестве 1-ой строки не нужна Строка-Заголовок, то
    // следует закомментировать следующий цикл:
	//НоваяСтрока = Новый Структура(СтруктураСтроки);
	//НоваяСтрока.НомерСтроки = 1;
	//Для ит = 1 ПО КолвоКолонокExcel Цикл
	//    
	//    ИмяКолонки = "К_" + ит;
	//    Колонка = ТаблицаРезультат.Колонки.Найти(ИмяКолонки);
	//    НоваяСтрока[ИмяКолонки] = Колонка.Заголовок;
	//    
	//КонецЦикла;
	//ТаблицаРезультат.Добавить(НоваяСтрока);
    
    // ТаблицаРезультат: Формирование строк по указанному диапазону: НачСтрока - КонСтрока.
    
    НомерСтроки = 1;
    Пока ADODBRecordset.EOF() = 0 Цикл
        
        НомерСтроки = НомерСтроки + 1;
        
        Если НомерСтроки < НачСтрока Тогда    // Номер строки вне диапазона считываемых строк.
            ADODBRecordset.MoveNext();             // Следующая строка.
            Продолжить;
        КонецЕсли;
        
        Если КонСтрока > 0 И НомерСтроки > КонСтрока Тогда    // Номер строки вне диапазона считываемых строк.
            Прервать;
        КонецЕсли;
        НоваяСтрока = Новый Структура(СтруктураСтроки);
        НоваяСтрока.НомерСтроки = НомерСтроки;
        
        Для ит = 1 ПО КолвоКолонокExcel Цикл
            
            Поле = ADODBRecordset.Fields.Item(ит - 1);
                
            Если Поле.ActualSize = 0 Тогда        // Пустое поле EXCEL.
                Продолжить;
            КонецЕсли;
                
            ЗначениеЯчейки = Поле.Value;        // Учитывая параметр HDR=YES в строке соединения, данные считываются в соответствии с их типом.
            
            ИмяКолонки = "К_" + ит;
            НоваяСтрока[ИмяКолонки] = ЗначениеЯчейки;
            
            // Используется при формировании таблицы на форме обработки.
			//ШиринаКолонки = ТаблицаРезультат.Колонки[ИмяКолонки].Ширина;
			//ДлинаСтроки      = СтрДлина(СокрЛП(ЗначениеЯчейки));
			//ТаблицаРезультат.Колонки[ИмяКолонки].Ширина = ?(ШиринаКолонки < ДлинаСтроки, ДлинаСтроки, ШиринаКолонки);
                
        КонецЦикла;
        ТаблицаРезультат.Добавить(НоваяСтрока);
        
        ADODBRecordset.MoveNext();   // Следующая строка.
        
    КонецЦикла;
    
    //УдалитьКолонкиСНулевойШириной(ТаблицаРезультат);
    
    // Завершение работы.
    // Закрытие Объектов.
    ADODBRecordset.Close();
    ADODBConnection.Close();
    ADODBRecordset   = Неопределено;
    ADODBConnection = Неопределено;
    
    Возврат ТаблицаРезультат;
    
КонецФункции

// Функция преобразует Массив из структур в ТаблицуЗначений.
//
&НаСервере
Функция ПреобразоватьМассивВТаблицуЗначений(мсДанные) Экспорт
    
    тзДанные = Новый ТаблицаЗначений;
    
    Для Каждого ЭлементМассива Из мсДанные Цикл
        // Рисуем колонки для таблицы
        Если тзДанные.Колонки.Количество() = 0 Тогда
            Для Каждого ЗначениеСтруктуры Из ЭлементМассива Цикл
                тзДанные.Колонки.Добавить(ЗначениеСтруктуры.Ключ);
            КонецЦикла;
        КонецЕсли;
        
        // Добавляем данные в таблицу
        НоваяСтрока = тзДанные.Добавить();
        Для Каждого ЗначениеСтруктуры Из ЭлементМассива Цикл
            НоваяСтрока[ЗначениеСтруктуры.Ключ] = ЗначениеСтруктуры.Значение;
        КонецЦикла;
    КонецЦикла;
    
    Возврат тзДанные;
    
КонецФункции // ПреобразоватьМассивВТаблицуЗначений()

&НаСервере
Процедура ПриЗагрузкеДанныхИзНастроекНаСервере(Настройки)
	РекТаблицаТиповДокументов = Настройки.Получить("Объект.РекТаблицаТиповДокументов");
	Если ЗначениеЗаполнено(РекТаблицаТиповДокументов) Тогда
		Если ТипЗнч(РекТаблицаТиповДокументов) = Тип("ХранилищеЗначения") Тогда
			ТаблицаТиповДокументов = РекТаблицаТиповДокументов.Получить();
			СтруктураПоиска = Новый Структура("ТипДокумента");
			Для Каждого СтрокаТЧ Из ТаблицаТиповДокументов Цикл
				СтруктураПоиска.ТипДокумента = СтрокаТЧ.ТипДокумента;
				Строки = Объект.ТаблицаТиповДокументов.НайтиСтроки(СтруктураПоиска);
				Если Строки.Количество() > 0 Тогда
					Строки[0].Признак = СтрокаТЧ.Признак;
				КонецЕсли;
			КонецЦикла;
		ИначеЕсли ТипЗнч(РекТаблицаТиповДокументов) = Тип("Структура") Тогда
			Для Каждого Элемент Из РекТаблицаТиповДокументов Цикл
				Строки = Объект.ТаблицаТиповДокументов.НайтиСтроки(Новый Структура("ТипДокумента", Элемент.Ключ));
				Если Строки.Количество() > 0 Тогда
					Строки[0].Признак = Элемент.Значение;
				КонецЕсли;
			КонецЦикла;
		КонецЕсли;
	КонецЕсли;
КонецПроцедуры

&НаСервере
Функция ЗаполнитьОтрОстаткиВсегоНаСервере()
	ОбъектДляСервера = РеквизитФормыВЗначение("Объект");
	
	ВыгрузкаЗавершена = ОбъектДляСервера.ЗаполнитьОтрицательныеОстаткиВсего();
	
	ЗначениеВРеквизитФормы(ОбъектДляСервера, "Объект");
	
	Возврат ВыгрузкаЗавершена;
КонецФункции

&НаКлиенте
Процедура ЗаполнитьОтрОстаткиВсего(Команда)
	ЗаполнитьОтрОстаткиВсегоНаСервере();
КонецПроцедуры

&НаСервере
Функция ВыгрОстРеалПост(ВыгружатьРеализацию, ВыгружатьПоступление)
		
	ОбъектДляСервера = РеквизитФормыВЗначение("Объект");
	ВыгрузкаЗавершена = ОбъектДляСервера.ВыгрузитьОстаткиКакРеалПост(ВыгружатьРеализацию, ВыгружатьПоступление);
	ЗначениеВРеквизитФормы(ОбъектДляСервера, "Объект");
	
	Возврат ВыгрузкаЗавершена;
КонецФункции

&НаКлиенте
Процедура ВыгрОстПоступлением(Команда)
	Состояние(Нстр("ru='Выполняется выгрузка документов. Пожалуйста, подождите...'"));
	Если ВыгрОстРеалПост(Ложь, Истина) Тогда
		
		Сообщить("Выгрузка документов успешно завершена.");
		
	КонецЕсли;
КонецПроцедуры

&НаКлиенте
Процедура ВыгрОстРеализацией(Команда)
	Состояние(Нстр("ru='Выполняется выгрузка документов. Пожалуйста, подождите...'"));
	Если ВыгрОстРеалПост(Истина, Ложь) Тогда
		
		Сообщить("Выгрузка документов успешно завершена.");
		
	КонецЕсли;
КонецПроцедуры

&НаСервере
// Преобразует текст формата XML в таблицу значений,
// при этом колонки таблицы формируются на основе описания в XML.
//
// Параметры:
//  XML     - текст в формате XML или ЧтениеXML.
//
// Схема XML:
// <?xml version="1.0" encoding="utf-8"?>
//  <xs:schema attributeFormDefault="unqualified" elementFormDefault="qualified" xmlns:xs="http://www.w3.org/2001/XMLSchema">
//   <xs:element name="Items">
//    <xs:complexType>
//     <xs:sequence>
//      <xs:element maxOccurs="unbounded" name="Item">
//       <xs:complexType>
//        <xs:attribute name="Code" type="xs:integer" use="required" />
//        <xs:attribute name="Name" type="xs:string" use="required" />
//        <xs:attribute name="Socr" type="xs:string" use="required" />
//        <xs:attribute name="Index" type="xs:string" use="required" />
//       </xs:complexType>
//      </xs:element>
//     </xs:sequence>
//    <xs:attribute name="Description" type="xs:string" use="required" />
//    <xs:attribute name="Columns" type="xs:string" use="required" />
//   </xs:complexType>
//  </xs:element>
// </xs:schema>
//
// Примеры XML-файлов см. в демонстрационной конфигурации.
// 
// Пример использования:
//   КлассификаторТаблица = ПрочитатьXMLВТаблицу(
//     Справочники.Валюты.ПолучитьМакет("ОбщероссийскийКлассификаторВалют").ПолучитьТекст()).Данные;
//
// Возвращаемое значение:
//  Структура - с полями 
//    * ИмяТаблицы - Строка
//    * Данные - ТаблицаЗначений.
//
Функция ПрочитатьXMLВТаблицу(Знач XML) Экспорт
	
	Если ТипЗнч(XML) <> Тип("ЧтениеXML") Тогда
		Чтение = Новый ЧтениеXML;
		Чтение.УстановитьСтроку(XML);
	Иначе
		Чтение = XML;
	КонецЕсли;
	
	// Прочитаем первый узел и проверим его.
	Если Не Чтение.Прочитать() Тогда
		ВызватьИсключение НСтр("ru = 'Пустой XML'");
	ИначеЕсли Чтение.Имя <> "Items" Тогда
		ВызватьИсключение НСтр("ru = 'Ошибка в структуре XML'");
	КонецЕсли;
	
	// Получим описание таблицы и создадим ее.
	ИмяТаблицы = Чтение.ПолучитьАтрибут("Description");
	ИменаКолонок = СтрЗаменить(Чтение.ПолучитьАтрибут("Columns"), ",", Символы.ПС);
	Колонок = СтрЧислоСтрок(ИменаКолонок);
	
	ТаблицаЗначений = Новый ТаблицаЗначений;
	Для Сч = 1 По Колонок Цикл
		ТаблицаЗначений.Колонки.Добавить(СтрПолучитьСтроку(ИменаКолонок, Сч), Новый ОписаниеТипов("Строка"));
	КонецЦикла;
	
	// Заполним значения в таблице.
	Пока Чтение.Прочитать() Цикл
		
		Если Чтение.ТипУзла = ТипУзлаXML.КонецЭлемента И Чтение.Имя = "Items" Тогда
			Прервать;
		ИначеЕсли Чтение.ТипУзла <> ТипУзлаXML.НачалоЭлемента Тогда
			Продолжить;
		ИначеЕсли Чтение.Имя <> "Item" Тогда
			ВызватьИсключение НСтр("ru = 'Ошибка в структуре XML'");
		КонецЕсли;
		
		новСтр = ТаблицаЗначений.Добавить();
		Для Сч = 1 По Колонок Цикл
			ИмяКолонки = СтрПолучитьСтроку(ИменаКолонок, Сч);
			новСтр[Сч-1] = Чтение.ПолучитьАтрибут(ИмяКолонки);
		КонецЦикла;
		
	КонецЦикла;
	
	// Заполним результат
	Результат = Новый Структура;
	Результат.Вставить("ИмяТаблицы", ИмяТаблицы);
	Результат.Вставить("Данные", ТаблицаЗначений);
	
	Возврат Результат;
	
КонецФункции

&НаКлиенте
Процедура ОчиститьТаб(Команда)
	Объект.ТаблицаЗакупокXLS.Очистить();
КонецПроцедуры

&НаСервере
Функция ЗагрузитьZXLSНаСервере(МассивXLS)
	ОбъектДляСервера = РеквизитФормыВЗначение("Объект");
	ТаблицаXLS = ПреобразоватьМассивВТаблицуЗначений(МассивXLS);
	Попытка
		ВыгрузкаЗавершена = ОбъектДляСервера.ЗагрузитьТаблицуZОтчетов(ТаблицаXLS);
	Исключение
		Сообщить(ОписаниеОшибки());
	КонецПопытки;
	ЗначениеВРеквизитФормы(ОбъектДляСервера, "Объект");
КонецФункции

&НаКлиенте
Процедура ЗагрузитьZXLS(Команда)
	Перем КолСтрок;
	МассивXLS = ЗагрузитьМетодом_MSADODB(Объект.ФайлXLS, "TDSheet", 1, 0, , КолСтрок);
	ЗагрузитьZXLSНаСервере(МассивXLS);
КонецПроцедуры

&НаКлиенте
Процедура ZОтчетыXLSПриАктивизацииСтроки(Элемент)
	
    Данные = Элементы.ZОтчетыXLS.ТекущиеДанные;
	Если Данные = Неопределено Тогда
		Если Элементы.ТаблицаЧеков.ОтборСтрок <> Неопределено Тогда
		    Элементы.ТаблицаЧеков.ОтборСтрок = Неопределено;
		КонецЕсли;
	Иначе
		ФиксированныйОтбор = Новый ФиксированнаяСтруктура("IdLocation, DOC_DATE",Данные.КодМагазина, Данные.Дата);
		Элементы.ТаблицаЧеков.ОтборСтрок = ФиксированныйОтбор;
	КонецЕсли;

	//НомерРаздела = Объект.Разделы.Индекс(Элементы.Разделы.ТекущиеДанные) + 1;

	//Элементы.Разделы.ТекущаяСтрока = Объект.Разделы[НомерРаздела - 1].ПолучитьИдентификатор();
КонецПроцедуры

&НаКлиенте
Процедура ПередЗакрытием(Отказ, ЗавершениеРаботы, ТекстПредупреждения, СтандартнаяОбработка)
	СтруктураТипов = Новый Структура;
	Для Каждого СтрокаТЧ Из Объект.ТаблицаТиповДокументов Цикл
		СтруктураТипов.Вставить(СтрокаТЧ.ТипДокумента, СтрокаТЧ.Признак);
	КонецЦикла;
	Объект.РекТаблицаТиповДокументов = СтруктураТипов;
КонецПроцедуры

&НаСервере
Функция ЗаполнитьОтрОстаткиПоДнямНаСервере()
	ОбъектДляСервера = РеквизитФормыВЗначение("Объект");
	
	ВыгрузкаЗавершена = ОбъектДляСервера.ЗаполнитьОтрицательныеОстаткиПоДням();
	
	ЗначениеВРеквизитФормы(ОбъектДляСервера, "Объект");
	
	Возврат ВыгрузкаЗавершена;
КонецФункции

&НаКлиенте
Процедура ЗаполнитьОтрОстаткиПоДням(Команда)
	ЗаполнитьОтрОстаткиПоДнямНаСервере();
КонецПроцедуры

&НаСервере
Функция ЗаполнитьОстаткиПоступлениямиНаСервере()
	ОбъектДляСервера = РеквизитФормыВЗначение("Объект");
	
	ВыгрузкаЗавершена = ОбъектДляСервера.ЗаполнитьПоступлениями();
	
	ЗначениеВРеквизитФормы(ОбъектДляСервера, "Объект");
	
	Возврат ВыгрузкаЗавершена;
КонецФункции

&НаКлиенте
Процедура ЗаполнитьОстаткиПоступлениями(Команда)
	ЗаполнитьОстаткиПоступлениямиНаСервере();
КонецПроцедуры

&НаСервереБезКонтекста
Процедура НайтиНеиспользуемыеТоварыНаСервере()
	Запрос = Новый Запрос("ВЫБРАТЬ
	|	СпрНоменклатуры.Ссылка
	|ИЗ
	|	Справочник.Номенклатура КАК СпрНоменклатуры
	|//ВНУТРЕННЕЕ СОЕДИНЕНИЕ
	|//	(ВЫБРАТЬ
	|//		Номенклатура.Код
	|//	ИЗ
	|//		Справочник.Номенклатура КАК Номенклатура
	|//	СГРУППИРОВАТЬ ПО
	|//		Номенклатура.Код
	|//	ИМЕЮЩИЕ
	|//		КОЛИЧЕСТВО(Номенклатура.Код) > 1
	|//	) КАК ТабДублей
	|//	ПО СпрНоменклатуры.Код = ТабДублей.Код
	|ЛЕВОЕ СОЕДИНЕНИЕ
	|	(ВЫБРАТЬ РАЗЛИЧНЫЕ
	|		ТабДок.Номенклатура КАК Номенклатура
	|	ИЗ
	|		Документ.ВозвратТоваровОтПокупателя КАК Док
	|	ВНУТРЕННЕЕ СОЕДИНЕНИЕ Документ.ВозвратТоваровОтПокупателя.Товары КАК ТабДок
	|		ПО Док.Ссылка = ТабДок.Ссылка
	|	ГДЕ
	|		Док.ПометкаУдаления = ЛОЖЬ
	|	ОБЪЕДИНИТЬ
	|	ВЫБРАТЬ РАЗЛИЧНЫЕ
	|		ТабДок.Номенклатура КАК Номенклатура
	|	ИЗ
	|		Документ.ОприходованиеТоваров КАК Док
	|	ВНУТРЕННЕЕ СОЕДИНЕНИЕ Документ.ОприходованиеТоваров.Товары КАК ТабДок
	|		ПО Док.Ссылка = ТабДок.Ссылка
	|	ГДЕ
	|		Док.ПометкаУдаления = ЛОЖЬ
	|	ОБЪЕДИНИТЬ
	|	ВЫБРАТЬ РАЗЛИЧНЫЕ
	|		ТабДок.Номенклатура КАК Номенклатура
	|	ИЗ
	|		Документ.ПоступлениеТоваровУслуг КАК Док
	|	ВНУТРЕННЕЕ СОЕДИНЕНИЕ Документ.ПоступлениеТоваровУслуг.Товары КАК ТабДок
	|		ПО Док.Ссылка = ТабДок.Ссылка
	|	ГДЕ
	|		Док.ПометкаУдаления = ЛОЖЬ
	|	ОБЪЕДИНИТЬ
	|	ВЫБРАТЬ РАЗЛИЧНЫЕ
	|		ТабДок.Номенклатура КАК Номенклатура
	|	ИЗ
	|		Документ.ПоступлениеТоваровУслуг КАК Док
	|	ВНУТРЕННЕЕ СОЕДИНЕНИЕ Документ.ПоступлениеТоваровУслуг.Услуги КАК ТабДок
	|		ПО Док.Ссылка = ТабДок.Ссылка
	|	ГДЕ
	|		Док.ПометкаУдаления = ЛОЖЬ
	|	ОБЪЕДИНИТЬ
	|	ВЫБРАТЬ РАЗЛИЧНЫЕ
	|		ТабДок.Номенклатура КАК Номенклатура
	|	ИЗ
	|		Документ.РеализацияТоваровУслуг КАК Док
	|	ВНУТРЕННЕЕ СОЕДИНЕНИЕ Документ.РеализацияТоваровУслуг.Товары КАК ТабДок
	|		ПО Док.Ссылка = ТабДок.Ссылка
	|	ГДЕ
	|		Док.ПометкаУдаления = ЛОЖЬ
	|	ОБЪЕДИНИТЬ
	|	ВЫБРАТЬ РАЗЛИЧНЫЕ
	|		ТабДок.Номенклатура КАК Номенклатура
	|	ИЗ
	|		Документ.РеализацияТоваровУслуг КАК Док
	|	ВНУТРЕННЕЕ СОЕДИНЕНИЕ Документ.РеализацияТоваровУслуг.Услуги КАК ТабДок
	|		ПО Док.Ссылка = ТабДок.Ссылка
	|	ГДЕ
	|		Док.ПометкаУдаления = ЛОЖЬ
	|	ОБЪЕДИНИТЬ
	|	ВЫБРАТЬ РАЗЛИЧНЫЕ
	|		ТабДок.Номенклатура КАК Номенклатура
	|	ИЗ
	|		Документ.ОтчетОРозничныхПродажах КАК Док
	|	ВНУТРЕННЕЕ СОЕДИНЕНИЕ Документ.ОтчетОРозничныхПродажах.Товары КАК ТабДок
	|		ПО Док.Ссылка = ТабДок.Ссылка
	|	ГДЕ
	|		Док.ПометкаУдаления = ЛОЖЬ) КАК ТоварыВДокументах
	|	ПО СпрНоменклатуры.Ссылка = ТоварыВДокументах.Номенклатура
	|ГДЕ
	|	ТоварыВДокументах.Номенклатура ЕСТЬ NULL");
	Выборка = Запрос.Выполнить().Выбрать();
	Пока Выборка.Следующий() Цикл
		Удаление = Новый УдалениеОбъекта(Выборка.Ссылка);
		Удаление.Записать();
	КонецЦикла;
	Запрос = Новый Запрос("ВЫБРАТЬ
	|	Группы.Ссылка
	|ИЗ
	|	Справочник.Номенклатура КАК Группы
	|ЛЕВОЕ СОЕДИНЕНИЕ
	|	(ВЫБРАТЬ РАЗЛИЧНЫЕ
	|		Номенклатура.Родитель КАК Родитель
	|	ИЗ
	|		Справочник.Номенклатура КАК Номенклатура
	|	) КАК ЭлементыГрупп
	|	ПО Группы.Ссылка = ЭлементыГрупп.Родитель
	|ГДЕ
	|	Группы.ЭтоГруппа = ИСТИНА
	|	И ЭлементыГрупп.Родитель ЕСТЬ NULL");
	Выборка = Запрос.Выполнить().Выбрать();
	Пока Выборка.Следующий() Цикл
		Удаление = Новый УдалениеОбъекта(Выборка.Ссылка);
		Удаление.Записать();
	КонецЦикла;
КонецПроцедуры

&НаКлиенте
Процедура НайтиНеиспользуемыеТовары(Команда)
	Состояние(Нстр("ru='Выполняется удаление номенклатуры. Пожалуйста, подождите...'"));
	НайтиНеиспользуемыеТоварыНаСервере();
	Состояние(Нстр("ru='Удаление номенклатуры завершено.'"));
КонецПроцедуры

&НаКлиенте
Процедура ТаблицаСуммДокументовПриАктивизацииСтроки(Элемент)
    Данные = Элемент.ТекущиеДанные;
	Если Данные = Неопределено Тогда
		Если Элементы.ТаблицаЗакупокXLS1.ОтборСтрок <> Неопределено Тогда
		    Элементы.ТаблицаЗакупокXLS1.ОтборСтрок = Неопределено;
		КонецЕсли;
	Иначе
		ФиксированныйОтбор = Новый ФиксированнаяСтруктура("НомерДокумента, ДатаДокумента",Данные.Номер, Данные.Дата);
		Элементы.ТаблицаЗакупокXLS1.ОтборСтрок = ФиксированныйОтбор;
	КонецЕсли;
КонецПроцедуры

&НаСервере
Процедура ЗагрузитьПоступленияНаСервере(МассивXLS)
	ОбъектДляСервера = РеквизитФормыВЗначение("Объект");
	ТаблицаXLS = ПреобразоватьМассивВТаблицуЗначений(МассивXLS);
	ВыгрузкаЗавершена = ОбъектДляСервера.ЗагрузитьТаблицуВнешнихПоступлений(ТаблицаXLS);
	ЗначениеВРеквизитФормы(ОбъектДляСервера, "Объект");
КонецПроцедуры

&НаКлиенте
Процедура ЗагрузитьПоступления(Команда)
	Перем КолСтрок;
	МассивXLS = ЗагрузитьМетодом_MSADODB(Объект.ФайлXLS, "TDSheet", 1, 0, , КолСтрок);
	ЗагрузитьПоступленияНаСервере(МассивXLS);
КонецПроцедуры

&НаКлиенте
Процедура ЗагрузитьСуммыПоступлений(Команда)
	Перем КолСтрок;
	МассивXLS = ЗагрузитьМетодом_MSADODB(Объект.ФайлXLS, "TDSheet", 1, 0, , КолСтрок);
	ЗагрузитьСуммыПоступленийНаСервере(МассивXLS);
КонецПроцедуры

&НаСервере
Процедура ЗагрузитьСуммыПоступленийНаСервере(МассивXLS)
	ОбъектДляСервера = РеквизитФормыВЗначение("Объект");
	ТаблицаXLS = ПреобразоватьМассивВТаблицуЗначений(МассивXLS);
	Объект.ТипДокументаПоУмолчанию = "ПостВнешнее";
	ВыгрузкаЗавершена = ОбъектДляСервера.ЗагрузитьСуммыПоступлений(ТаблицаXLS);
	ЗначениеВРеквизитФормы(ОбъектДляСервера, "Объект");
КонецПроцедуры

&НаКлиенте
Процедура ТаблицаЧековDOC_DATEПриИзменении(Элемент)
	РасчетныйНомер = "ПР" + Лев(Элемент.Родитель.ТекущиеДанные.IdLocation, 3) + Формат(Элемент.Родитель.ТекущиеДанные.Doc_Date, "ДФ=yyMMdd");
	Если Элемент.Родитель.ТекущиеДанные.DOC_ID <> РасчетныйНомер Тогда
		Элемент.Родитель.ТекущиеДанные.DOC_ID = РасчетныйНомер;
	КонецЕсли;
КонецПроцедуры

&НаСервере
Процедура РаспределитьПоступленияНаСервере()
	ОбъектДляСервера = РеквизитФормыВЗначение("Объект");
	ОбъектДляСервера.РаспределитьПоступления(-1);
	ЗначениеВРеквизитФормы(ОбъектДляСервера, "Объект");
КонецПроцедуры

&НаКлиенте
Процедура РаспределитьПоступления(Команда)
	РаспределитьПоступленияНаСервере();
КонецПроцедуры

&НаСервере
Процедура РаспределитьПоступленияВозрНаСервере()
	ОбъектДляСервера = РеквизитФормыВЗначение("Объект");
	ОбъектДляСервера.РаспределитьПоступления(1);
	ЗначениеВРеквизитФормы(ОбъектДляСервера, "Объект");
КонецПроцедуры

&НаКлиенте
Процедура РаспределитьПоступленияВозр(Команда)
	РаспределитьПоступленияВозрНаСервере();
КонецПроцедуры

&НаСервере
Процедура ЗагрузитьПоступленияИзДокументовНаСервере()
	ОбъектДляСервера = РеквизитФормыВЗначение("Объект");
	
	ВыгрузкаЗавершена = ОбъектДляСервера.ЗаполнитьПоступленияИзДокументов();
	
	ЗначениеВРеквизитФормы(ОбъектДляСервера, "Объект");
КонецПроцедуры

&НаКлиенте
Процедура ЗагрузитьПоступленияИзДокументов(Команда)
	ЗагрузитьПоступленияИзДокументовНаСервере();
КонецПроцедуры

ТипыДокументов = Новый Структура;
ТипыДокументов.Вставить("Импорт", Истина);
ТипыДокументов.Вставить("Поступление", Истина);
ТипыДокументов.Вставить("Отгрузка", Истина);
ТипыДокументов.Вставить("ПродажаРозница", Истина);
ТипыДокументов.Вставить("ВозвратРозница", Истина);
ТипыДокументов.Вставить("ПродажаДистриб", Истина);
ТипыДокументов.Вставить("ВозвратДистриб", Истина);
ТипыДокументов.Вставить("ПостНекоммерция", Истина);
ТипыДокументов.Вставить("ГТДНекоммерция", Истина);
ТипыДокументов.Вставить("ПостВнешнее", Истина);
ТипыДокументов.Вставить("РеалВнешняя", Истина);
ТипыДокументов.Вставить("РеалНекоммерция", Истина);
ТипыДокументов.Вставить("ОтчётКомитенту", Ложь);
ТипыДокументов.Вставить("ОстРеализ", Ложь);
ТипыДокументов.Вставить("ОстПоступл", Ложь);
ТипыДокументов.Вставить("ОстОприход", Ложь);
